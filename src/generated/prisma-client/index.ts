// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  city: (where?: CityWhereInput) => Promise<boolean>;
  job: (where?: JobWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  city: (where: CityWhereUniqueInput) => CityNullablePromise;
  cities: (args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<City>;
  citiesConnection: (args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CityConnectionPromise;
  job: (where: JobWhereUniqueInput) => JobNullablePromise;
  jobs: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Job>;
  jobsConnection: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JobConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createCity: (data: CityCreateInput) => CityPromise;
  updateCity: (args: {
    data: CityUpdateInput;
    where: CityWhereUniqueInput;
  }) => CityPromise;
  updateManyCities: (args: {
    data: CityUpdateManyMutationInput;
    where?: CityWhereInput;
  }) => BatchPayloadPromise;
  upsertCity: (args: {
    where: CityWhereUniqueInput;
    create: CityCreateInput;
    update: CityUpdateInput;
  }) => CityPromise;
  deleteCity: (where: CityWhereUniqueInput) => CityPromise;
  deleteManyCities: (where?: CityWhereInput) => BatchPayloadPromise;
  createJob: (data: JobCreateInput) => JobPromise;
  updateJob: (args: {
    data: JobUpdateInput;
    where: JobWhereUniqueInput;
  }) => JobPromise;
  updateManyJobs: (args: {
    data: JobUpdateManyMutationInput;
    where?: JobWhereInput;
  }) => BatchPayloadPromise;
  upsertJob: (args: {
    where: JobWhereUniqueInput;
    create: JobCreateInput;
    update: JobUpdateInput;
  }) => JobPromise;
  deleteJob: (where: JobWhereUniqueInput) => JobPromise;
  deleteManyJobs: (where?: JobWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  city: (
    where?: CitySubscriptionWhereInput
  ) => CitySubscriptionPayloadSubscription;
  job: (
    where?: JobSubscriptionWhereInput
  ) => JobSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Permission = "BASIC" | "ADMIN";

export type Status =
  | "EXPIRED"
  | "REJECTED"
  | "PENDING"
  | "APPROVED"
  | "REMOVED";

export type JobOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "url_ASC"
  | "url_DESC"
  | "company_ASC"
  | "company_DESC"
  | "description_ASC"
  | "description_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "published_at_ASC"
  | "published_at_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "status_ASC"
  | "status_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type TagOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type CityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "name_ASC"
  | "name_DESC"
  | "district_ASC"
  | "district_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "password_ASC"
  | "password_DESC"
  | "email_ASC"
  | "email_DESC"
  | "permission_ASC"
  | "permission_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  jobs_every?: Maybe<JobWhereInput>;
  jobs_some?: Maybe<JobWhereInput>;
  jobs_none?: Maybe<JobWhereInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  permission?: Maybe<Permission>;
  permission_not?: Maybe<Permission>;
  permission_in?: Maybe<Permission[] | Permission>;
  permission_not_in?: Maybe<Permission[] | Permission>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  password: String;
  email: String;
  permission?: Maybe<Permission>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
}

export interface CategoryUpdateManyWithoutJobsInput {
  create?: Maybe<
    CategoryCreateWithoutJobsInput[] | CategoryCreateWithoutJobsInput
  >;
  delete?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  set?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  disconnect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  update?: Maybe<
    | CategoryUpdateWithWhereUniqueWithoutJobsInput[]
    | CategoryUpdateWithWhereUniqueWithoutJobsInput
  >;
  upsert?: Maybe<
    | CategoryUpsertWithWhereUniqueWithoutJobsInput[]
    | CategoryUpsertWithWhereUniqueWithoutJobsInput
  >;
  deleteMany?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  updateMany?: Maybe<
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput
  >;
}

export interface TagCreateManyWithoutJobsInput {
  create?: Maybe<TagCreateWithoutJobsInput[] | TagCreateWithoutJobsInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface TagUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface TagCreateWithoutJobsInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  OR?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  NOT?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface CategoryUpdateInput {
  name?: Maybe<String>;
  jobs?: Maybe<JobUpdateManyWithoutCategoriesInput>;
}

export interface CityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  district?: Maybe<String>;
  district_not?: Maybe<String>;
  district_in?: Maybe<String[] | String>;
  district_not_in?: Maybe<String[] | String>;
  district_lt?: Maybe<String>;
  district_lte?: Maybe<String>;
  district_gt?: Maybe<String>;
  district_gte?: Maybe<String>;
  district_contains?: Maybe<String>;
  district_not_contains?: Maybe<String>;
  district_starts_with?: Maybe<String>;
  district_not_starts_with?: Maybe<String>;
  district_ends_with?: Maybe<String>;
  district_not_ends_with?: Maybe<String>;
  jobs_every?: Maybe<JobWhereInput>;
  jobs_some?: Maybe<JobWhereInput>;
  jobs_none?: Maybe<JobWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CityWhereInput[] | CityWhereInput>;
  OR?: Maybe<CityWhereInput[] | CityWhereInput>;
  NOT?: Maybe<CityWhereInput[] | CityWhereInput>;
}

export interface JobUpdateManyWithoutCategoriesInput {
  create?: Maybe<
    JobCreateWithoutCategoriesInput[] | JobCreateWithoutCategoriesInput
  >;
  delete?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  connect?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  set?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  disconnect?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  update?: Maybe<
    | JobUpdateWithWhereUniqueWithoutCategoriesInput[]
    | JobUpdateWithWhereUniqueWithoutCategoriesInput
  >;
  upsert?: Maybe<
    | JobUpsertWithWhereUniqueWithoutCategoriesInput[]
    | JobUpsertWithWhereUniqueWithoutCategoriesInput
  >;
  deleteMany?: Maybe<JobScalarWhereInput[] | JobScalarWhereInput>;
  updateMany?: Maybe<
    JobUpdateManyWithWhereNestedInput[] | JobUpdateManyWithWhereNestedInput
  >;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface JobUpdateWithWhereUniqueWithoutCategoriesInput {
  where: JobWhereUniqueInput;
  data: JobUpdateWithoutCategoriesDataInput;
}

export interface UserUpdateInput {
  password?: Maybe<String>;
  email?: Maybe<String>;
  permission?: Maybe<Permission>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
}

export interface JobUpdateWithoutCategoriesDataInput {
  title?: Maybe<String>;
  url?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  city?: Maybe<CityUpdateOneRequiredWithoutJobsInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  published_at?: Maybe<DateTimeInput>;
  tags?: Maybe<TagUpdateManyWithoutJobsInput>;
  status?: Maybe<Status>;
  shortDescription?: Maybe<String>;
}

export interface JobUpsertWithWhereUniqueWithoutTagsInput {
  where: JobWhereUniqueInput;
  update: JobUpdateWithoutTagsDataInput;
  create: JobCreateWithoutTagsInput;
}

export interface CityUpdateOneRequiredWithoutJobsInput {
  create?: Maybe<CityCreateWithoutJobsInput>;
  update?: Maybe<CityUpdateWithoutJobsDataInput>;
  upsert?: Maybe<CityUpsertWithoutJobsInput>;
  connect?: Maybe<CityWhereUniqueInput>;
}

export interface JobWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  company?: Maybe<String>;
  company_not?: Maybe<String>;
  company_in?: Maybe<String[] | String>;
  company_not_in?: Maybe<String[] | String>;
  company_lt?: Maybe<String>;
  company_lte?: Maybe<String>;
  company_gt?: Maybe<String>;
  company_gte?: Maybe<String>;
  company_contains?: Maybe<String>;
  company_not_contains?: Maybe<String>;
  company_starts_with?: Maybe<String>;
  company_not_starts_with?: Maybe<String>;
  company_ends_with?: Maybe<String>;
  company_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  city?: Maybe<CityWhereInput>;
  creator?: Maybe<UserWhereInput>;
  published_at?: Maybe<DateTimeInput>;
  published_at_not?: Maybe<DateTimeInput>;
  published_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  published_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  published_at_lt?: Maybe<DateTimeInput>;
  published_at_lte?: Maybe<DateTimeInput>;
  published_at_gt?: Maybe<DateTimeInput>;
  published_at_gte?: Maybe<DateTimeInput>;
  categories_every?: Maybe<CategoryWhereInput>;
  categories_some?: Maybe<CategoryWhereInput>;
  categories_none?: Maybe<CategoryWhereInput>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<Status>;
  status_not?: Maybe<Status>;
  status_in?: Maybe<Status[] | Status>;
  status_not_in?: Maybe<Status[] | Status>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  AND?: Maybe<JobWhereInput[] | JobWhereInput>;
  OR?: Maybe<JobWhereInput[] | JobWhereInput>;
  NOT?: Maybe<JobWhereInput[] | JobWhereInput>;
}

export interface CityUpdateWithoutJobsDataInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  name?: Maybe<String>;
  district?: Maybe<String>;
}

export interface JobUpdateWithWhereUniqueWithoutTagsInput {
  where: JobWhereUniqueInput;
  data: JobUpdateWithoutTagsDataInput;
}

export interface CityUpsertWithoutJobsInput {
  update: CityUpdateWithoutJobsDataInput;
  create: CityCreateWithoutJobsInput;
}

export type JobWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface JobCreateWithoutTagsInput {
  id?: Maybe<ID_Input>;
  title: String;
  url?: Maybe<String>;
  company: String;
  description: String;
  slug: String;
  city: CityCreateOneWithoutJobsInput;
  creator: UserCreateOneInput;
  published_at?: Maybe<DateTimeInput>;
  categories?: Maybe<CategoryCreateManyWithoutJobsInput>;
  status?: Maybe<Status>;
  shortDescription: String;
}

export interface UserUpdateDataInput {
  password?: Maybe<String>;
  email?: Maybe<String>;
  permission?: Maybe<Permission>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface JobUpdateManyMutationInput {
  title?: Maybe<String>;
  url?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  published_at?: Maybe<DateTimeInput>;
  status?: Maybe<Status>;
  shortDescription?: Maybe<String>;
}

export interface TagUpdateManyWithoutJobsInput {
  create?: Maybe<TagCreateWithoutJobsInput[] | TagCreateWithoutJobsInput>;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  update?: Maybe<
    | TagUpdateWithWhereUniqueWithoutJobsInput[]
    | TagUpdateWithWhereUniqueWithoutJobsInput
  >;
  upsert?: Maybe<
    | TagUpsertWithWhereUniqueWithoutJobsInput[]
    | TagUpsertWithWhereUniqueWithoutJobsInput
  >;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  resetToken?: Maybe<String>;
}>;

export interface TagUpdateWithWhereUniqueWithoutJobsInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutJobsDataInput;
}

export interface CityUpdateManyMutationInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  name?: Maybe<String>;
  district?: Maybe<String>;
}

export interface TagUpdateWithoutJobsDataInput {
  name?: Maybe<String>;
}

export interface CategoryUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface TagUpsertWithWhereUniqueWithoutJobsInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutJobsDataInput;
  create: TagCreateWithoutJobsInput;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  jobs?: Maybe<JobCreateManyWithoutCategoriesInput>;
}

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  jobs_every?: Maybe<JobWhereInput>;
  jobs_some?: Maybe<JobWhereInput>;
  jobs_none?: Maybe<JobWhereInput>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
  OR?: Maybe<TagWhereInput[] | TagWhereInput>;
  NOT?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface JobCreateWithoutCategoriesInput {
  id?: Maybe<ID_Input>;
  title: String;
  url?: Maybe<String>;
  company: String;
  description: String;
  slug: String;
  city: CityCreateOneWithoutJobsInput;
  creator: UserCreateOneInput;
  published_at?: Maybe<DateTimeInput>;
  tags?: Maybe<TagCreateManyWithoutJobsInput>;
  status?: Maybe<Status>;
  shortDescription: String;
}

export interface CategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  OR?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  NOT?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
}

export interface CityCreateWithoutJobsInput {
  id?: Maybe<ID_Input>;
  lat: Float;
  lng: Float;
  name: String;
  district: String;
}

export interface CategoryUpsertWithWhereUniqueWithoutJobsInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateWithoutJobsDataInput;
  create: CategoryCreateWithoutJobsInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface JobUpsertWithWhereUniqueWithoutCategoriesInput {
  where: JobWhereUniqueInput;
  update: JobUpdateWithoutCategoriesDataInput;
  create: JobCreateWithoutCategoriesInput;
}

export interface CitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CityWhereInput>;
  AND?: Maybe<CitySubscriptionWhereInput[] | CitySubscriptionWhereInput>;
  OR?: Maybe<CitySubscriptionWhereInput[] | CitySubscriptionWhereInput>;
  NOT?: Maybe<CitySubscriptionWhereInput[] | CitySubscriptionWhereInput>;
}

export interface JobScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  company?: Maybe<String>;
  company_not?: Maybe<String>;
  company_in?: Maybe<String[] | String>;
  company_not_in?: Maybe<String[] | String>;
  company_lt?: Maybe<String>;
  company_lte?: Maybe<String>;
  company_gt?: Maybe<String>;
  company_gte?: Maybe<String>;
  company_contains?: Maybe<String>;
  company_not_contains?: Maybe<String>;
  company_starts_with?: Maybe<String>;
  company_not_starts_with?: Maybe<String>;
  company_ends_with?: Maybe<String>;
  company_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  published_at?: Maybe<DateTimeInput>;
  published_at_not?: Maybe<DateTimeInput>;
  published_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  published_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  published_at_lt?: Maybe<DateTimeInput>;
  published_at_lte?: Maybe<DateTimeInput>;
  published_at_gt?: Maybe<DateTimeInput>;
  published_at_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<Status>;
  status_not?: Maybe<Status>;
  status_in?: Maybe<Status[] | Status>;
  status_not_in?: Maybe<Status[] | Status>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  AND?: Maybe<JobScalarWhereInput[] | JobScalarWhereInput>;
  OR?: Maybe<JobScalarWhereInput[] | JobScalarWhereInput>;
  NOT?: Maybe<JobScalarWhereInput[] | JobScalarWhereInput>;
}

export interface TagUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface JobUpdateManyWithWhereNestedInput {
  where: JobScalarWhereInput;
  data: JobUpdateManyDataInput;
}

export interface JobUpdateWithoutTagsDataInput {
  title?: Maybe<String>;
  url?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  city?: Maybe<CityUpdateOneRequiredWithoutJobsInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  published_at?: Maybe<DateTimeInput>;
  categories?: Maybe<CategoryUpdateManyWithoutJobsInput>;
  status?: Maybe<Status>;
  shortDescription?: Maybe<String>;
}

export interface JobUpdateManyDataInput {
  title?: Maybe<String>;
  url?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  published_at?: Maybe<DateTimeInput>;
  status?: Maybe<Status>;
  shortDescription?: Maybe<String>;
}

export interface TagUpdateInput {
  name?: Maybe<String>;
  jobs?: Maybe<JobUpdateManyWithoutTagsInput>;
}

export interface CategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  jobs?: Maybe<JobCreateManyWithoutTagsInput>;
}

export interface CategoryUpdateWithoutJobsDataInput {
  name?: Maybe<String>;
}

export interface JobCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  url?: Maybe<String>;
  company: String;
  description: String;
  slug: String;
  city: CityCreateOneWithoutJobsInput;
  creator: UserCreateOneInput;
  published_at?: Maybe<DateTimeInput>;
  categories?: Maybe<CategoryCreateManyWithoutJobsInput>;
  tags?: Maybe<TagCreateManyWithoutJobsInput>;
  status?: Maybe<Status>;
  shortDescription: String;
}

export interface CategoryUpdateWithWhereUniqueWithoutJobsInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateWithoutJobsDataInput;
}

export interface CityCreateOneWithoutJobsInput {
  create?: Maybe<CityCreateWithoutJobsInput>;
  connect?: Maybe<CityWhereUniqueInput>;
}

export interface CityCreateInput {
  id?: Maybe<ID_Input>;
  lat: Float;
  lng: Float;
  name: String;
  district: String;
  jobs?: Maybe<JobCreateManyWithoutCityInput>;
}

export interface JobSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<JobWhereInput>;
  AND?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
  OR?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
  NOT?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
}

export interface JobCreateManyWithoutCityInput {
  create?: Maybe<JobCreateWithoutCityInput[] | JobCreateWithoutCityInput>;
  connect?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
}

export type CityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface JobCreateWithoutCityInput {
  id?: Maybe<ID_Input>;
  title: String;
  url?: Maybe<String>;
  company: String;
  description: String;
  slug: String;
  creator: UserCreateOneInput;
  published_at?: Maybe<DateTimeInput>;
  categories?: Maybe<CategoryCreateManyWithoutJobsInput>;
  tags?: Maybe<TagCreateManyWithoutJobsInput>;
  status?: Maybe<Status>;
  shortDescription: String;
}

export interface JobCreateManyWithoutTagsInput {
  create?: Maybe<JobCreateWithoutTagsInput[] | JobCreateWithoutTagsInput>;
  connect?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
}

export interface CategoryCreateManyWithoutJobsInput {
  create?: Maybe<
    CategoryCreateWithoutJobsInput[] | CategoryCreateWithoutJobsInput
  >;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
}

export interface JobUpsertWithWhereUniqueWithoutCityInput {
  where: JobWhereUniqueInput;
  update: JobUpdateWithoutCityDataInput;
  create: JobCreateWithoutCityInput;
}

export interface CategoryCreateWithoutJobsInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface JobUpdateWithoutCityDataInput {
  title?: Maybe<String>;
  url?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  published_at?: Maybe<DateTimeInput>;
  categories?: Maybe<CategoryUpdateManyWithoutJobsInput>;
  tags?: Maybe<TagUpdateManyWithoutJobsInput>;
  status?: Maybe<Status>;
  shortDescription?: Maybe<String>;
}

export interface JobUpdateWithWhereUniqueWithoutCityInput {
  where: JobWhereUniqueInput;
  data: JobUpdateWithoutCityDataInput;
}

export interface JobUpdateManyWithoutCityInput {
  create?: Maybe<JobCreateWithoutCityInput[] | JobCreateWithoutCityInput>;
  delete?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  connect?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  set?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  disconnect?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  update?: Maybe<
    | JobUpdateWithWhereUniqueWithoutCityInput[]
    | JobUpdateWithWhereUniqueWithoutCityInput
  >;
  upsert?: Maybe<
    | JobUpsertWithWhereUniqueWithoutCityInput[]
    | JobUpsertWithWhereUniqueWithoutCityInput
  >;
  deleteMany?: Maybe<JobScalarWhereInput[] | JobScalarWhereInput>;
  updateMany?: Maybe<
    JobUpdateManyWithWhereNestedInput[] | JobUpdateManyWithWhereNestedInput
  >;
}

export interface CityUpdateInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  name?: Maybe<String>;
  district?: Maybe<String>;
  jobs?: Maybe<JobUpdateManyWithoutCityInput>;
}

export interface UserUpdateManyMutationInput {
  password?: Maybe<String>;
  email?: Maybe<String>;
  permission?: Maybe<Permission>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
}

export interface JobCreateManyWithoutCategoriesInput {
  create?: Maybe<
    JobCreateWithoutCategoriesInput[] | JobCreateWithoutCategoriesInput
  >;
  connect?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
}

export interface JobUpdateInput {
  title?: Maybe<String>;
  url?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  city?: Maybe<CityUpdateOneRequiredWithoutJobsInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  published_at?: Maybe<DateTimeInput>;
  categories?: Maybe<CategoryUpdateManyWithoutJobsInput>;
  tags?: Maybe<TagUpdateManyWithoutJobsInput>;
  status?: Maybe<Status>;
  shortDescription?: Maybe<String>;
}

export interface JobUpdateManyWithoutTagsInput {
  create?: Maybe<JobCreateWithoutTagsInput[] | JobCreateWithoutTagsInput>;
  delete?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  connect?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  set?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  disconnect?: Maybe<JobWhereUniqueInput[] | JobWhereUniqueInput>;
  update?: Maybe<
    | JobUpdateWithWhereUniqueWithoutTagsInput[]
    | JobUpdateWithWhereUniqueWithoutTagsInput
  >;
  upsert?: Maybe<
    | JobUpsertWithWhereUniqueWithoutTagsInput[]
    | JobUpsertWithWhereUniqueWithoutTagsInput
  >;
  deleteMany?: Maybe<JobScalarWhereInput[] | JobScalarWhereInput>;
  updateMany?: Maybe<
    JobUpdateManyWithWhereNestedInput[] | JobUpdateManyWithWhereNestedInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  password: String;
  email: String;
  permission: Permission;
  resetToken?: String;
  resetTokenExpiry?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  permission: () => Promise<Permission>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  permission: () => Promise<AsyncIterator<Permission>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CityEdge {
  node: City;
  cursor: String;
}

export interface CityEdgePromise extends Promise<CityEdge>, Fragmentable {
  node: <T = CityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CityEdgeSubscription
  extends Promise<AsyncIterator<CityEdge>>,
    Fragmentable {
  node: <T = CitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface JobPreviousValues {
  id: ID_Output;
  title: String;
  url?: String;
  company: String;
  description: String;
  slug: String;
  published_at?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status: Status;
  shortDescription: String;
}

export interface JobPreviousValuesPromise
  extends Promise<JobPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  url: () => Promise<String>;
  company: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  published_at: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  status: () => Promise<Status>;
  shortDescription: () => Promise<String>;
}

export interface JobPreviousValuesSubscription
  extends Promise<AsyncIterator<JobPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  published_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<Status>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
}

export interface CityConnection {
  pageInfo: PageInfo;
  edges: CityEdge[];
}

export interface CityConnectionPromise
  extends Promise<CityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CityEdge>>() => T;
  aggregate: <T = AggregateCityPromise>() => T;
}

export interface CityConnectionSubscription
  extends Promise<AsyncIterator<CityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCitySubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagPreviousValues {
  id: ID_Output;
  name: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface JobEdge {
  node: Job;
  cursor: String;
}

export interface JobEdgePromise extends Promise<JobEdge>, Fragmentable {
  node: <T = JobPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JobEdgeSubscription
  extends Promise<AsyncIterator<JobEdge>>,
    Fragmentable {
  node: <T = JobSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface AggregateCity {
  count: Int;
}

export interface AggregateCityPromise
  extends Promise<AggregateCity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCitySubscription
  extends Promise<AsyncIterator<AggregateCity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  name: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface City {
  id: ID_Output;
  lat: Float;
  lng: Float;
  name: String;
  district: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CityPromise extends Promise<City>, Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  name: () => Promise<String>;
  district: () => Promise<String>;
  jobs: <T = FragmentableArray<Job>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CitySubscription
  extends Promise<AsyncIterator<City>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  name: () => Promise<AsyncIterator<String>>;
  district: () => Promise<AsyncIterator<String>>;
  jobs: <T = Promise<AsyncIterator<JobSubscription>>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CityNullablePromise
  extends Promise<City | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  name: () => Promise<String>;
  district: () => Promise<String>;
  jobs: <T = FragmentableArray<Job>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Tag {
  id: ID_Output;
  name: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  jobs: <T = FragmentableArray<Job>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  jobs: <T = Promise<AsyncIterator<JobSubscription>>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  jobs: <T = FragmentableArray<Job>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Category {
  id: ID_Output;
  name: String;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  jobs: <T = FragmentableArray<Job>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  jobs: <T = Promise<AsyncIterator<JobSubscription>>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  jobs: <T = FragmentableArray<Job>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateJob {
  count: Int;
}

export interface AggregateJobPromise
  extends Promise<AggregateJob>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJobSubscription
  extends Promise<AsyncIterator<AggregateJob>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface JobSubscriptionPayload {
  mutation: MutationType;
  node: Job;
  updatedFields: String[];
  previousValues: JobPreviousValues;
}

export interface JobSubscriptionPayloadPromise
  extends Promise<JobSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JobPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JobPreviousValuesPromise>() => T;
}

export interface JobSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JobSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JobSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JobPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  password: String;
  email: String;
  permission: Permission;
  resetToken?: String;
  resetTokenExpiry?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  permission: () => Promise<Permission>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  permission: () => Promise<AsyncIterator<Permission>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  permission: () => Promise<Permission>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CityPreviousValues {
  id: ID_Output;
  lat: Float;
  lng: Float;
  name: String;
  district: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CityPreviousValuesPromise
  extends Promise<CityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  name: () => Promise<String>;
  district: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CityPreviousValuesSubscription
  extends Promise<AsyncIterator<CityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  name: () => Promise<AsyncIterator<String>>;
  district: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CitySubscriptionPayload {
  mutation: MutationType;
  node: City;
  updatedFields: String[];
  previousValues: CityPreviousValues;
}

export interface CitySubscriptionPayloadPromise
  extends Promise<CitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CityPreviousValuesPromise>() => T;
}

export interface CitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CityPreviousValuesSubscription>() => T;
}

export interface JobConnection {
  pageInfo: PageInfo;
  edges: JobEdge[];
}

export interface JobConnectionPromise
  extends Promise<JobConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JobEdge>>() => T;
  aggregate: <T = AggregateJobPromise>() => T;
}

export interface JobConnectionSubscription
  extends Promise<AsyncIterator<JobConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JobEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJobSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Job {
  id: ID_Output;
  title: String;
  url?: String;
  company: String;
  description: String;
  slug: String;
  published_at?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status: Status;
  shortDescription: String;
}

export interface JobPromise extends Promise<Job>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  url: () => Promise<String>;
  company: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  city: <T = CityPromise>() => T;
  creator: <T = UserPromise>() => T;
  published_at: () => Promise<DateTimeOutput>;
  categories: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  status: () => Promise<Status>;
  shortDescription: () => Promise<String>;
}

export interface JobSubscription
  extends Promise<AsyncIterator<Job>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  city: <T = CitySubscription>() => T;
  creator: <T = UserSubscription>() => T;
  published_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  categories: <T = Promise<AsyncIterator<CategorySubscription>>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<Status>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
}

export interface JobNullablePromise extends Promise<Job | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  url: () => Promise<String>;
  company: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  city: <T = CityPromise>() => T;
  creator: <T = UserPromise>() => T;
  published_at: () => Promise<DateTimeOutput>;
  categories: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  status: () => Promise<Status>;
  shortDescription: () => Promise<String>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "Status",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "City",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Job",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
